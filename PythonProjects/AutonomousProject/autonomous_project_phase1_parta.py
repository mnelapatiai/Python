# -*- coding: utf-8 -*-
"""Autonomous_Project_Phase1_PartA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H-M8gEOpwDI8KuKF4O2PkTrIcEC_vkmO

# R2

## Creating a graph with 10 nodes and average connectivity of 2
"""

import networkx as nx
import matplotlib.pyplot as plt
import random
# Create an empty graph
G = nx.Graph()

# Add nodes (0 to 9)
nodes = range(10)
G.add_nodes_from(nodes)

# Define edge information with weights
edges_with_weights = [
    (0, 3, 0.1), (0, 8, 0.8), (3, 8, 0.8), (2, 8, 0.7), (8, 1, 1.0),
    (8, 6, 0.7), (1, 6, 1.0), (1, 4, 0.6), (6, 4, 0.5), (6, 7, 0.9),
    (4, 7, 0.4), (7, 9, 0.4), (4, 9, 1.0), (7, 5, 0.8), (4, 5, 0.5)
]

"""## Printing the contents of service queues and paths for each van and plotting for 2 vans"""

# Add edges with weights to the graph
for edge in edges_with_weights:
    G.add_edge(edge[0], edge[1], weight=edge[2])

# Initialize van data structures
vans = [{'id': i, 'location': 0, 'service_queue_van0': [], 'service_queue_van1': [], 'path': [0]} for i in range(0, 2)]

# Function to calculate weighted distance between two nodes using dijkstra
def calculate_weighted_distance(graph, node1, node2):
    return nx.shortest_path(graph,node1,node2,weight='weight',method='dijkstra')

# Function to get the next node for a van
def get_next_node(graph, van, destination):
    path = vans[van]['path']
    current_location = vans[van]['location']

    # Calculate distances to all neighboring nodes
    distances = [(node, calculate_weighted_distance(graph, current_location, node)) for node in G.neighbors(current_location)]

    # Sort distances and choose the closest node as the next destination
    distances.sort(key=lambda x: x[1])

    for node, _ in distances:
        if node not in path:
            return node

    # If all nodes are visited, return to the starting point
    return path[0]

# Clock ticks
for tick in range(1, 21):
    print(f"At clock tick {tick}")

    # Generate pickup and drop-off requests
    pickup_location_van0 = random.randint(0, 9)
    dropoff_location_van0 = random.randint(0, 9)
    pickup_location_van1 = random.randint(0, 9)
    dropoff_location_van1 = random.randint(0, 9)

    # Select a van for the pickup request based on proximity
    available_vans = [van for van in vans if len(van['service_queue_van0']) < 5 and len(van['service_queue_van1']) < 5]
    if available_vans:
        closest_van = min(available_vans, key=lambda van: calculate_weighted_distance(G, van['location'], pickup_location_van0))
        closest_van['service_queue_van0'].extend([(tick, 'p', pickup_location_van0), (tick, 'd', dropoff_location_van0)])
        closest_van1 = min(available_vans, key=lambda van: calculate_weighted_distance(G, van['location'], pickup_location_van1))
        closest_van1['service_queue_van1'].extend([(tick, 'p', pickup_location_van1), (tick, 'd', dropoff_location_van1)])

    # Update van paths
    for van in vans:
        if van['service_queue_van0'] and van['service_queue_van1']:
            next_node = get_next_node(G, van['id'], van['service_queue_van0'][0][2])
            next_node1 = get_next_node(G, van['id'], van['service_queue_van1'][0][2])
            van['path'].append(next_node)
            van['location'] = next_node
            van['path'].append(next_node1)
            van['location'] = next_node1

    # Print contents of service queues and paths for each van
    print(f"In the array of service_queue, the 1st value refers to customer ID and 2nd value refers to service type either pickup or dropoff and 3rd value refers to pickup node if the service is p and dropoff node if service type is d")
    for van in vans:
        print(f"Van {van['id']} - Service Queue: {van['service_queue_van0'], van['service_queue_van1']}")
    # Plot the graph at this clock tick
    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=True, node_size=300)
    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
    plt.title(f"Graph at Clock Tick {tick}")
    plt.show()

"""# R3

## Calculating average distance traveled per day and average number of trips per day on a road network of 100 nodes and average connectivity of 3 for 30 vans
"""

import networkx as nx
import random
# Create a random graph with 100 nodes and average connectivity of 3
G = nx.random_regular_graph(3, 100)
# Initialize van data structures
vans = [{'id': i, 'location': 0, 'service_queue': [], 'path': [0]} for i in range(1, 31)]

# Function to calculate weighted distance between two nodes
def calculate_weighted_distance(graph, node1, node2):
    # Replace this with actual distance calculation based on traffic density
    return random.uniform(0.1, 2.0)  # Example: Uniform random distance between 0.1 and 2.0

# Function to get the next node for a van
def get_next_node(graph, van, destination):
    path = vans[van]['path']
    current_location = vans[van]['location']

    # Calculate distances to all neighboring nodes
    distances = [(node, calculate_weighted_distance(graph, current_location, node)) for node in G.neighbors(current_location)]

    # Sort distances and choose the closest node as the next destination
    distances.sort(key=lambda x: x[1])

    for node, _ in distances:
        if node not in path:
            return node

    # If all nodes are visited, return to the starting point
    return path[0]

# Simulate 10 hours (10 * 60 minutes)
total_distance = 0
total_trips = 0

for tick in range(1, 10 * 60 + 1):
    # Generate random pickup and drop-off requests
    if random.random() < 0.01:  # Randomly generate requests with 1% probability per minute
        pickup_location = random.randint(0, 99)  # Random pickup node
        dropoff_location = random.randint(0, 99)  # Random drop-off node
        total_trips += 1

        # Select a van for the pickup request based on proximity
        available_vans = [van for van in vans if len(van['service_queue']) < 5]
        if available_vans:
            closest_van = min(available_vans, key=lambda van: calculate_weighted_distance(G, van['location'], pickup_location))
            closest_van['service_queue'].extend([(tick, 'p', pickup_location), (tick, 'd', dropoff_location)])

    # Update van paths
    for van in vans:
        if van['service_queue']:
            next_node = get_next_node(G, van['id'], van['service_queue'][0][2])
            van['path'].append(next_node)
            total_distance += calculate_weighted_distance(G, van['location'], next_node)
            van['location'] = next_node

# Calculate average distance traveled per day
average_distance_per_day = total_distance / 10  # 10-hour simulation

# Calculate average number of trips per day
average_trips_per_day = total_trips / 10  # 10-hour simulation

print(f"Average Distance Traveled per Day: {average_distance_per_day}")
print(f"Average Number of Trips per Day: {average_trips_per_day}")

"""# R4

##Calculating the new values of average distance and average number of trips traveled per day taken across the entire fleet on a road network of 100 nodes and average connectivity of 3 for 60 vans
"""

import networkx as nx
import random
# Create a random graph with 100 nodes and average connectivity of 3
G = nx.random_regular_graph(3, 100)
# Initialize van data structures
vans = [{'id': i, 'location': 0, 'service_queue': [], 'path': [0]} for i in range(1, 61)]  # Change fleet size to 60
# Function to calculate weighted distance between two nodes
def calculate_weighted_distance(graph, node1, node2):
    # Replace this with actual distance calculation based on traffic density
    return random.uniform(0.1, 2.0)  # Example: Uniform random distance between 0.1 and 2.0

# Function to get the next node for a van
def get_next_node(graph, van, destination):
    path = vans[van]['path']
    current_location = vans[van]['location']

    # Calculate distances to all neighboring nodes
    distances = [(node, calculate_weighted_distance(graph, current_location, node)) for node in G.neighbors(current_location)]

    # Sort distances and choose the closest node as the next destination
    distances.sort(key=lambda x: x[1])

    for node, _ in distances:
        if node not in path:
            return node

    # If all nodes are visited, return to the starting point
    return path[0]

# Simulate 10 hours (10 * 60 minutes)
total_distance = 0
total_trips = 0

for tick in range(1, 10 * 60 + 1):
    # Generate random pickup and drop-off requests
    if random.random() < 0.01:  # Randomly generate requests with 1% probability per minute
        pickup_location = random.randint(0, 99)  # Random pickup node
        dropoff_location = random.randint(0, 99)  # Random drop-off node
        total_trips += 1

        # Select a van for the pickup request based on proximity
        available_vans = [van for van in vans if len(van['service_queue']) < 5]
        if available_vans:
            closest_van = min(available_vans, key=lambda van: calculate_weighted_distance(G, van['location'], pickup_location))
            closest_van['service_queue'].extend([(tick, 'p', pickup_location), (tick, 'd', dropoff_location)])

    # Update van paths
    for van in vans:
        if van['service_queue']:
            next_node = get_next_node(G, van['id'], van['service_queue'][0][2])
            van['path'].append(next_node)
            total_distance += calculate_weighted_distance(G, van['location'], next_node)
            van['location'] = next_node

# Calculate average distance traveled per day
average_distance_per_day = total_distance / 10  # 10-hour simulation

# Calculate average number of trips per day
average_trips_per_day = total_trips / 10  # 10-hour simulation

print(f"Average Distance Traveled per Day with 60 Vehicles: {average_distance_per_day}")
print(f"Average Number of Trips per Day with 60 Vehicles: {average_trips_per_day}")

"""#R5

##Calculating the new values of average distance traveled per day taken across the entire fleet on a road network of 100 nodes and average connectivity of 4 for 60 vans
"""

import networkx as nx
import random

# Create a random graph with 100 nodes and connectivity of 4
G = nx.random_regular_graph(4, 100)

# Initialize van data structures
vans = [{'id': i, 'location': 0, 'service_queue': [], 'path': [0]} for i in range(1, 61)]

# Function to calculate weighted distance between two nodes
def calculate_weighted_distance(graph, node1, node2):
    # Replace this with actual distance calculation based on traffic density
    return random.uniform(0.1, 2.0)  # Example: Uniform random distance between 0.1 and 2.0

# Function to get the next node for a van
def get_next_node(graph, van, destination):
    path = vans[van]['path']
    current_location = vans[van]['location']

    # Calculate distances to all neighboring nodes
    distances = [(node, calculate_weighted_distance(graph, current_location, node)) for node in G.neighbors(current_location)]

    # Sort distances and choose the closest node as the next destination
    distances.sort(key=lambda x: x[1])

    for node, _ in distances:
        if node not in path:
            return node

    # If all nodes are visited, return to the starting point
    return path[0]

# Simulate 10 hours (10 * 60 minutes) with the given booking rate (450 to 600 reservations per hour)
total_distance = 0
total_trips = 0
# average_distance_per_minute = []
for tick in range(1, 10 * 60 + 1):
    # Generate random pickup and drop-off requests
    if random.random() < random.uniform(7.5, 10.0) / 60:  # Randomly generate requests with rate between 7.5 to 10 requests per minute
        pickup_location = random.randint(0, 99)  # Random pickup node
        dropoff_location = random.randint(0, 99)  # Random drop-off node
        total_trips += 1

        # Select a van for the pickup request based on proximity
        available_vans = [van for van in vans if len(van['service_queue']) < 5]
        if available_vans:
            closest_van = min(available_vans, key=lambda van: calculate_weighted_distance(G, van['location'], pickup_location))
            closest_van['service_queue'].extend([(tick, 'p', pickup_location), (tick, 'd', dropoff_location)])

    # Update van paths
    for van in vans:
        if van['service_queue']:
            next_node = get_next_node(G, van['id'], van['service_queue'][0][2])
            van['path'].append(next_node)
            total_distance += calculate_weighted_distance(G, van['location'], next_node)
            van['location'] = next_node

# Calculate average distance traveled per day
average_distance_per_day = total_distance / 10  # 10-hour simulation

print(f"New Average Distance Traveled per Day with Connectivity of 4: {average_distance_per_day}")