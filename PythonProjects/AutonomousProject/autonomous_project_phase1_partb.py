# -*- coding: utf-8 -*-
"""Autonomous_Project_Phase1_PartB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SFzIymNKh56rzyK1l0VmJw0ZVtwYsJ8q

# Part A - Pseudo code

```
# Importing Matplotlib library and NetworkX library for Fig1A and Fig1B Visualization and operations
# Defining constants and creating the initial directed graph for Figure 1A
num_nodes = #nodes value
G_A = CreateDirectedGraph(num_nodes)

# Adding edges with capacities and flows for Figure 1A
G_A.add_edges_from(edge_data_A)  # Adding edges to the graph with associated capacity and flow information.

# Define the hill climbing algorithm to optimize the graph
function HillClimbing(G):
    while True:
        for var1, var2 in G.edges:  # Iterate through the edges of the graph.
            capacity = G[var1][var2]['capacity']  # Retrieve the capacity of the edge.
            flow = G[var1][var2]['flow']  # Retrieve the current flow on the edge.
            if flow < capacity:  # If the flow is less than the capacity, there is room for improvement.
                G[var1][v]['flow'] = capacity  # Optimize the flow to match the capacity.
                improved = True  # Set the 'improved' flag to True.
        if not improved:  # If no improvements were made in the iteration, exit the loop.
            break

# Applying hill climbing to optimize the flow in Figure 1A
HillClimbing(G_A)  # Calling the hill climbing algorithm to optimize the flow in the graph.

# Creating a copy of the optimized graph for Figure 1B
G_B = CopyGraph(G_A)  # Creating a copy of the optimized graph for further visualization.

# Defining a function to visualize the graph
function VisualizeGraph(graph, title):
    pos = DefineLayout(graph)  # Define the layout for graph visualization.
    SetFigureSize(number, number)  # Set the figure size for the plot.
    DrawNodes(grafh, position)  # visualize node points.
    DrawEdges(grafh, position)  # visualize edges of graph.
    SetTitle(title)  # Set the title for the graph.
    ShowPlot()  # Display the graph.
# Visualize the original graph (Figure 1A)
visualize_graph(G_A, "Figure 1A: Flow into T before optimization")  # Visualize the original graph.
# Visualize the optimized graph (Figure 1B)
visualize_graph(G_B, "Figure 1B: Flow into T after optimization with hill climbing")  # Visualize the optimized graph.

# Calculate total flow value for Figure 1A
total_flow_A = CalculateTotalFlow(G_A)# Calculate the total flow in the original graph.

# Calculate total flow value for Figure 1B
total_flow_B = CalculateTotalFlow(G_B)   # Calculate the total flow in the optimized graph.

# Check if the total flow values for Figure 1A and Figure 1B match.
if total_flow_A == total_flow_B:
    Print('success')  # Print a success message.
else:
    Print("failed")  # Print a failure message.

# Pseudo code for Heuristic Function for HC Algorithm
Function heuristic(node, graph)
    h_values = []  # Create a blank list to hold the values for your heuristics.
    for child in graph.successors(node): # Calculate the remaining capacity for each child node of the current node
        remaining_capacity = graph[node][child]['capacity'] - graph[node][child]['flow']
        h_values.append(remaining_capacity)  # Calculate and store remaining capacity

    if h_values is empty:
        return -1  # Return a negative value when no remaining capacity
    else:
        return max(h_values)  # Return the maximum remaining capacity among children
        # The heuristic function assesses the remaining capacity of outgoing edges from a given node.
# Define the select_child function for the HC algorithm
Function select_child(h_values): # The select_child function chooses a child node to move to based on heuristic values and random selection.


# Pseudo code for Successor Function for HC Algorithm
Function successor(node, graph)
    successors = []  # Initialize an empty list to store child nodes
        successors.append(child)  # Add each child node to the list
    return successors  # Give the current node's immediate children as a list.
    # A list of the immediate children of the current node is retrieved and returned by the successor function.
# Remove redundant paths
 successors = remove_redundant_paths(successors)


# Pseudo code for Hill Climbing Algorithm
Function hill_climbing(source, sink, graph)
    current_node = source  # Initialize the current node with the source node
    current_path = []  # Create an empty list from scratch to hold the path.

    while current_node is not equal to sink:
        h_values = []  # Create a blank list to hold the values for your heuristics.
        successors = successor(current_node, graph)  # Get the immediate child nodes
        for child in successors:
            h_values.append(heuristic(current_node, graph))  # Calculate heuristic values for children
        if all(h <= 0 for h in h_values):
            break  # Local minimum reached, break out of the loop
         # Select a child node to move to based on the select_child function
        i = select_child(h_values)  # Use the select_child function to choose a child node
        next_node = successors[i]  # Select the next node based on the chosen child
        current_node = next_node  # Update the current node
        current_path.append((current_node, graph[current_node]))  # Append the current node to the path
        # The hill_climbing function performs the hill-climbing algorithm to find a path from the source to the sink node in the graph.
    return current_path  # Return the path from source to sink

# Calculate the total flow using the Edmonds-Karp algorithm
R = EdmondsKarpAlgorithm(G, source, sink)  # Compute the maximum flow graph using Edmonds-Karp
total_flow_ek = CalculateTotalFlow(R, source, sink)  # Calculate the total flow value

#Average total flow for 30 graphs where average connectivity 3
# Define the number of random graphs to generate
num_graphs = #grafh count to 30
# Initialize a variable to store the total flows from each random graph
total_flows = #flow count to null
# Loop through a range of 'num_graphs' and calculate the total flow for each graph
for i in range(num_graphs):
    total_flow = GenerateRandomGraphAndCalculateFlow()  # Generate a random graph and calculate its total flow
# Calculate the average total flow by dividing the total flows by the number of graphs
average_total_flow = total_flows / num_graphs

#Average total flow for 30 graphs where average connectivity 2
# Define the number of random graphs to generate
num_graphs = #grapf count to 30
# Create a blank list and fill it with the total flows from each random graph.
total_flows = #flow count to null
# Loop through a range of 'num_graphs' and calculate the total flow for each graph
for i in range(num_graphs):
    total_flow = GenerateAndCalculateRandomGraphFlow()  # Generate a random graph and calculate its total flow
# Calculate the average total flow by dividing the sum of total flows by the number of graphs
average_total_flow = sum(total_flows) / num_graphs


```

# Part-B
"""

import networkx as nx
import random
import matplotlib.pyplot as plt

def heuristic(node, graph):
    h_values = []

    # Calculate the remaining capacity for each child node of the current node
    for child in graph.successors(node):
        remaining_capacity = graph[node][child]['capacity'] - graph[node][child]['flow']
        h_values.append(remaining_capacity)

    if not h_values:
        return -1  # Return a negative value when no remaining capacity is available

    return max(h_values)

def successor(node, graph):
    # Return a list of immediate child nodes of the current node
    return list(graph.successors(node))

def hc_algorithm(source, sink, graph):
    # Initialize the current node as the source node
    current_node = source
    current_path = []  # Store the current path
    total_flow = 0  # Initialize the total flow to zero

    # Continue searching for augmenting paths until the current node reaches the sink
    while current_node != sink:
        h_values = []  # Initialize a list to store the remaining capacity of outgoing edges
        successors = successor(current_node, graph)  # Find all successors of the current node

        # Calculate the remaining capacity (h-values) for each outgoing edge
        for child in successors:
            #remaining_capacity = graph[current_node][child]['capacity'] - graph[current_node][child]['flow']
            h_values.append(heuristic(current_node, graph))

        # If there are no positive h-values, or remaining capacity, exit the loop
        if all(h <= 0 for h in h_values):
            break

        # Select a child node to move to based on h-values
        i = select_child(h_values)  # Implement the select_child function to choose the next node
        next_node = successors[i]  # Get the chosen next node
        flow_on_edge = min(h_values[i], graph[current_node][next_node]['capacity'])  # Determine the flow on the edge

        # Update the flow on the selected edge
        graph[current_node][next_node]['flow'] += flow_on_edge
        current_node = next_node  # Move to the next node
        current_path.append((current_node, graph[current_node]))  # Update the current path
        total_flow += flow_on_edge  # Update the total flow with the flow on the edge

    # Return the final path and total flow achieved
    return current_path, total_flow

def select_child(h_values):
    # Calculate the total h-values or the sum of remaining capacities
    total_h = sum(h_values)

    # If total_h is zero, select a child randomly from the list
    if total_h == 0:
        return random.choice(range(len(h_values)))

    # Generate a random value between 0 and the total_h
    rand_val = random.uniform(0, total_h)
    cumulative_sum = 0

    # Iterate through the h-values to find the child node to select
    for i, h in enumerate(h_values):
        cumulative_sum += h
        # If the random value falls within the cumulative range, return the corresponding child node
        if rand_val <= cumulative_sum:
            return i

def visualize_graph(G, title):
    # Generate a layout for the nodes in the graph
    pos = nx.spring_layout(G)

    # Create labels for edges using flow values
    labels = {(i, j): G[i][j]['flow'] for i, j in G.edges()}

    # Determine edge colors based on flow-to-capacity ratio
    edge_colors = [G[i][j]['flow'] / G[i][j]['capacity'] for i, j in G.edges()]

    # Create a single Matplotlib figure
    fig, ax = plt.subplots()
    ax.set_title(title)

    # Draw the graph nodes with labels
    nx.draw(G, pos, with_labels=True, node_size=1000, node_color='skyblue', font_size=8)

    # Add edge labels with flow values
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels, font_size=6, label_pos=0.5)

    # Draw the edges with colors based on the flow-to-capacity ratio
    nx.draw(G, pos, edgelist=G.edges(), edge_color=edge_colors, edge_cmap=plt.get_cmap('bwr'), width=2.0, arrows=True)

    # Show the graph visualization
    plt.show()

"""# R1: Visualize the solution for Figure 1B and calculate the total flow"""

num_nodes = 6
G_A = nx.DiGraph()

# Define the graph for Figure 1A with edge data
edge_data_A = [
    (0, 1, {'capacity': 6, 'flow': 2}),
    (0, 2, {'capacity': 3, 'flow': 3}),
    (0, 3, {'capacity': 5, 'flow': 4}),
    (1, 2, {'capacity': 5, 'flow': 1}),
    (1, 4, {'capacity': 3, 'flow': 1}),
    (2, 4, {'capacity': 9, 'flow': 2}),
    (2, 5, {'capacity': 8, 'flow': 4}),
    (3, 2, {'capacity': 2, 'flow': 2}),
    (3, 4, {'capacity': 3, 'flow': 2}),
    (4, 5, {'capacity': 5, 'flow': 4}),
]

G_A.add_nodes_from(range(num_nodes))
G_A.add_edges_from(edge_data_A)

# Apply HC algorithm to optimize flow in Figure 1A
path_A, total_flow_A = hc_algorithm(0, num_nodes - 1, G_A)

# Create a copy of the optimized graph for Figure 1B
G_B = G_A.copy()

print("Node Pairs | Flow/Capacity")
print("---------------------------")

for edge in edge_data_A:
    node1, node2, data = edge
    flow = data['flow']
    capacity = data['capacity']
    print(f"{node1} -> {node2} | {flow}/{capacity}")

# Visualize the optimized graph for Figure 1B
visualize_graph(G_B, "Figure 1B: Flow into T after optimization with HC algorithm")

# Print the total flow into the sink node T for Figure 1A
print("Total flow into the sink node T (Figure 1A):", total_flow_A)

"""# R2: Run stochastic HC code on a graph G with Edmonds-Karp comparison"""

# Number of nodes in the graph
num_nodes = 30

# Generate a random graph with 30 nodes and average connectivity of 3 (0.1 probability)
G = nx.gnp_random_graph(num_nodes, 0.1, directed=True)

# Initialize dictionaries to store capacities, inflow, and outflow for each node
capacities = {}
inflow = {}
outflow = {}

# Initialize capacities, inflow, and outflow dictionaries for each node
for node in G.nodes:
    capacities[node] = {}
    inflow[node] = 0
    outflow[node] = 0

# Assign random capacities to edges in the range of 1 to 10
for u, v in G.edges:
    capacity = random.randint(1, 10)
    G[u][v]['capacity'] = capacity

# Assign random flow values to edges within the capacity range
for edge in G.edges:
    G[edge[0]][edge[1]]['flow'] = random.randint(1, G[edge[0]][edge[1]]['capacity'])

# Source and sink nodes
source = 0
sink = num_nodes - 1

total_flow_hc = 0
current_node = source

# Run Hill-Climbing (HC) algorithm to maximize flow
while current_node != sink:
    h_values = []
    successors = list(G.successors(current_node))

    # Calculate remaining capacities for each outgoing edge from the current node
    for child in successors:
        h_values.append(G[current_node][child]['capacity'] - G[current_node][child]['flow'])

    # If all remaining capacities are non-positive, break the loop
    if all(h <= 0 for h in h_values):
        break

    # Select a child node based on remaining capacities and update flow
    i = select_child(h_values)
    next_node = successors[i]
    flow_on_edge = min(h_values[i], G[current_node][next_node]['capacity'])
    G[current_node][next_node]['flow'] += flow_on_edge
    current_node = next_node

    # Update total flow for HC algorithm
    total_flow_hc += flow_on_edge

# Use Edmonds-Karp algorithm for comparison
R = nx.algorithms.flow.edmonds_karp(G, source, sink)
total_flow_ek = nx.maximum_flow_value(R, source, sink)

# Print total flow values from HC and Edmonds-Karp algorithms
print("Total flow value from HC algorithm:", total_flow_hc)
print("Optimal total flow value from Edmonds Karp algorithm:", total_flow_ek)

"""# R3-a: Calculate the average total flow for random graphs with average connectivity of 3"""

# Stochastic Hill Climbing Algorithm
def stochastic_hc(N):
    # Number of random graphs to generate and average
    num_graphs = 30
    total_flows_avg3 = []

    for i in range(num_graphs):
        num_nodes = 30

        # Generate a random graph with 30 nodes and average connectivity of 3 (0.1 probability)
        G = nx.gnp_random_graph(num_nodes, N/num_nodes, directed=True)
        capacities = {}
        inflow = {}
        outflow = {}

        for node in G.nodes:
            capacities[node] = {}
            inflow[node] = 0
            outflow[node] = 0

        # Assign random capacities to edges in the range of 1 to 10
        for u, v in G.edges:
            capacity = random.randint(1, 10)
            G[u][v]['capacity'] = capacity

        # Assign random flow values to edges within the capacity range
        for edge in G.edges:
            G[edge[0]][edge[1]]['flow'] = random.randint(1, G[edge[0]][edge[1]]['capacity'])

        source = 0
        sink = num_nodes - 1

        total_flow_hc = 0
        current_node = source

        # Run Hill-Climbing (HC) algorithm to maximize flow
        while current_node != sink:
            h_values = []
            successors = list(G.successors(current_node))

            # Calculate remaining capacities for each outgoing edge from the current node
            for child in successors:
                h_values.append(G[current_node][child]['capacity'] - G[current_node][child]['flow'])

            # If all remaining capacities are non-positive, break the loop
            if all(h <= 0 for h in h_values):
                break

            # Select a child node based on remaining capacities and update flow
            i = select_child(h_values)
            next_node = successors[i]
            flow_on_edge = min(h_values[i], G[current_node][next_node]['capacity'])
            G[current_node][next_node]['flow'] += flow_on_edge
            current_node = next_node

            # Update total flow for HC algorithm
            total_flow_hc += flow_on_edge

        total_flows_avg3.append(total_flow_hc)

    # Calculate the average total flow for average connectivity of 3
    average_total_flow_avg3 = sum(total_flows_avg3) / num_graphs
    return average_total_flow_avg3 # returns Average total flow for average connectivity 3

"""# R3-b: Calculate the average total flow for random graphs with average connectivity of 2"""

# Stochastic Hill Climbing Algorithm
def stochastic_hc(N):
    # Number of random graphs to generate and average
    num_graphs = 30
    total_flows_avg2 = []

    for i in range(num_graphs):
        num_nodes = 30

        # Generate a random graph with 30 nodes and average connectivity of 2
        G = nx.gnp_random_graph(num_nodes, N/num_nodes, directed=True)
        capacities = {}
        inflow = {}
        outflow = {}

        for node in G.nodes:
            capacities[node] = {}
            inflow[node] = 0
            outflow[node] = 0

        # Assign random capacities to edges in the range of 1 to 10
        for u, v in G.edges:
            capacity = random.randint(1, 10)
            G[u][v]['capacity'] = capacity

        # Assign random flow values to edges within the capacity range
        for edge in G.edges:
            G[edge[0]][edge[1]]['flow'] = random.randint(1, G[edge[0]][edge[1]]['capacity'])

        source = 0
        sink = num_nodes - 1

        total_flow_hc = 0
        current_node = source

        # Run Hill-Climbing (HC) algorithm to maximize flow
        while current_node != sink:
            h_values = []
            successors = list(G.successors(current_node))

            # Calculate remaining capacities for each outgoing edge from the current node
            for child in successors:
                h_values.append(G[current_node][child]['capacity'] - G[current_node][child]['flow'])

            # If all remaining capacities are non-positive, break the loop
            if all(h <= 0 for h in h_values):
                break

            # Select a child node based on remaining capacities and update flow
            i = select_child(h_values)
            next_node = successors[i]
            flow_on_edge = min(h_values[i], G[current_node][next_node]['capacity'])
            G[current_node][next_node]['flow'] += flow_on_edge
            current_node = next_node

            # Update total flow for HC algorithm
            total_flow_hc += flow_on_edge

        total_flows_avg2.append(total_flow_hc)

    # Calculate the average total flow for average connectivity of 3
    average_total_flow_avg2 = sum(total_flows_avg2) / num_graphs
    return average_total_flow_avg2 # returns Average total flow for average connectivity 3

tf_net_avg3 = stochastic_hc(3)
tf_net_avg2 = stochastic_hc(2)
print("Average total flow for average connectivity 3:", tf_net_avg3)
print("Average total flow for average connectivity 2:", tf_net_avg2)
if tf_net_avg3 > tf_net_avg2:
    print("Average total flow for average connectivity 3 is greater.")
elif tf_net_avg3 < tf_net_avg2:
    print("Average total flow for average connectivity 2 is greater.")
else:
    print("No significant difference between average connectivities.")

"""# R3-C

The significant difference observed between the average total flow values for graphs with average connectivity of 3 (tf_net_avg(3)) and graphs with average connectivity of 2 (tf_net_avg(2)) can be attributed to several key factors.

Firstly, the average connectivity of a graph plays a pivotal role in determining the flow characteristics. In the case of higher average connectivity (3 in this instance), there are a greater number of available pathways for flow to traverse. This abundance of routes leads to an increased total flow value as compared to situations with lower average connectivity (2), where fewer pathways limit the flow capacity.

Secondly, the incorporation of randomness in the generation of random graphs with varying capacities and flows introduces an element of unpredictability. The unique configuration of each random graph can influence flow capacity and the optimal flow paths. As a result, certain random graphs with average connectivity 2 may feature configurations that allow for efficient flow, while others may not.

Additionally, the choice of optimization algorithm is crucial. The Hill-Climbing (HC) algorithm employed in this context may not consistently discover the optimal flow, especially in graphs with reduced connectivity. Conversely, the Edmonds-Karp algorithm guarantees the identification of the optimal flow. The disparity in results between the HC algorithm and the Edmonds-Karp algorithm underscores the inherent limitations of the HC algorithm, particularly in graphs with lower connectivity.

Lastly, it is important to acknowledge that the results are based on a relatively modest sample size, consisting of 30 random graphs for each level of connectivity. With a larger sample size, any disparities observed could potentially become more statistically significant.

In summary, the discernible contrast in total flow values between graphs with average connectivity of 3 and 2 can be ascribed to the interplay of factors such as connectivity, randomness, algorithm choice, and the size of the sample used for analysis. Higher average connectivity generally affords more flow opportunities, resulting in higher average total flow values.
"""